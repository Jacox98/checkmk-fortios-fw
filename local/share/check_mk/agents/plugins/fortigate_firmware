#!/usr/bin/env python3

import sys
import os
import json
import base64
import requests
import argparse
from urllib3.exceptions import InsecureRequestWarning
from typing import Dict, Any, Optional
from requests import exceptions as req_exc

# Disabilita avvisi SSL
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def main():
    parser = argparse.ArgumentParser(description="CheckMK Special Agent for FortiGate")
    parser.add_argument("--hostname", required=True, help="FortiGate hostname or IP")
    parser.add_argument("--api-key", required=True, help="FortiGate API key")
    parser.add_argument("--port", type=int, default=443, help="HTTPS port (default: 443)")
    parser.add_argument("--timeout", type=int, default=30, help="Timeout in seconds")
    parser.add_argument(
        "--branch-change-critical",
        dest="branch_change_critical",
        action="store_true",
        default=True,
        help="Consider branch change critical (default)",
    )
    parser.add_argument(
        "--no-branch-change-critical",
        dest="branch_change_critical",
        action="store_false",
        help="Do not consider branch change critical",
    )

    # OpenCVE integration options
    parser.add_argument("--opencve-enabled", dest="opencve_enabled", action="store_true", default=False,
                        help="Enable OpenCVE lookup for product CVEs")
    parser.add_argument("--opencve-base-url", dest="opencve_base_url", default="https://app.opencve.io",
                        help="OpenCVE base URL (self-hostable)")
    parser.add_argument("--opencve-user", dest="opencve_user", default=None, help="OpenCVE username")
    parser.add_argument("--opencve-pass", dest="opencve_pass", default=None, help="OpenCVE password (from ruleset)")
    parser.add_argument("--opencve-vendor", dest="opencve_vendor", default=None, help="Product vendor name")
    parser.add_argument("--opencve-product", dest="opencve_product", default=None, help="Product name")
    parser.add_argument("--opencve-conn-timeout", dest="opencve_conn_timeout", type=int, default=20,
                        help="Timeout in seconds for OpenCVE requests")
    parser.add_argument("--opencve-list-limit", dest="opencve_list_limit", type=int, default=10,
                        help="Max number of CVE IDs to include from first page")
    parser.add_argument("--opencve-warn-threshold", dest="opencve_warn_threshold", type=int, default=1,
                        help=" WARN when total CVEs >= this value")
    parser.add_argument("--opencve-crit-threshold", dest="opencve_crit_threshold", type=int, default=5,
                        help=" CRIT when total CVEs >= this value")
    parser.add_argument("--opencve-no-verify", dest="opencve_no_verify", action="store_true", default=False,
                        help="Disable SSL verification for OpenCVE requests (self-hosted with self-signed certs)")
    parser.add_argument("--opencve-debug", dest="opencve_debug", action="store_true", default=False,
                        help="Print OpenCVE debug info to stderr (status and small body snippet)")
    
    args = parser.parse_args()
    
    base_url = f"https://{args.hostname}:{args.port}/api/v2"
    headers = {
        "Authorization": f"Bearer {args.api_key}",
        "Content-Type": "application/json"
    }
    
    # Helper to classify exceptions into structured, short messages
    def _error_payload(exc: Exception, endpoint: str) -> Dict[str, Any]:
        msg = str(exc)
        text = msg.lower()
        error_type = "request"
        # Classify common connection issues
        if isinstance(exc, (req_exc.ConnectTimeout, req_exc.ReadTimeout, req_exc.Timeout)) or "timed out" in text:
            error_type = "timeout"
            short = "Connection timed out"
        elif isinstance(exc, req_exc.SSLError) or "ssl" in text:
            error_type = "ssl"
            short = "SSL error"
        elif isinstance(exc, req_exc.ConnectionError) or any(s in text for s in [
            "failed to establish a new connection",
            "no route to host",
            "name or service not known",
            "temporary failure in name resolution",
            "connection refused",
        ]):
            error_type = "connection"
            # Try to produce a concise, friendly message
            if "no route to host" in text:
                short = "No route to host"
            elif "name or service not known" in text or "name resolution" in text:
                short = "DNS resolution failed"
            elif "connection refused" in text:
                short = "Connection refused"
            else:
                short = "Failed to connect"
        elif isinstance(exc, req_exc.HTTPError):
            error_type = "http"
            status = getattr(exc.response, 'status_code', 'unknown')
            short = f"HTTP error: {status}"
        else:
            short = "Request failed"

        payload: Dict[str, Any] = {
            "status": "error",
            "error": error_type,
            "message": short,
            "endpoint": endpoint,
            "detail": msg,
        }
        # Attach HTTP response details if available
        try:
            if isinstance(exc, req_exc.HTTPError) and exc.response is not None:
                payload["http_status"] = getattr(exc.response, 'status_code', None)
                payload["reason"] = getattr(exc.response, 'reason', None)
                body = exc.response.text or ""
                if body:
                    payload["response_snippet"] = body[:400]
        except Exception:
            pass
        return payload

    def _normalize_firmware_payload(payload: Any) -> Any:
        """FortiOS 7.6 returns firmware data in a flatter schema.

        Older releases wrapped everything inside "results" while newer ones expose
        "current"/"available" at the top level. Unify the shape so that the
        agent-based check keeps working regardless of the appliance version.
        """

        if not isinstance(payload, dict):
            return payload

        normalized: Dict[str, Any] = dict(payload)
        existing_results = normalized.get("results")
        results: Dict[str, Any] = dict(existing_results) if isinstance(existing_results, dict) else {}

        for key in ("current", "running", "installed", "active"):
            current_obj = normalized.get(key)
            if isinstance(current_obj, dict) and "current" not in results:
                results["current"] = current_obj
                break

        for key in ("available", "images", "upgrades", "upgrade_images", "firmwares"):
            available_list = normalized.get(key)
            if isinstance(available_list, list) and "available" not in results:
                results["available"] = available_list
                break

        if results:
            normalized["results"] = results

        normalized.setdefault("status", "success")
        return normalized

    # Ottieni informazioni sistema
    try:
        response = requests.get(
            f"{base_url}/monitor/system/status",
            headers=headers,
            verify=False,
            timeout=args.timeout,
        )
        response.raise_for_status()
        system_data = response.json()

        print("<<<fortigate_system:sep(0)>>>")
        print(json.dumps(system_data))

    except Exception as e:
        print("<<<fortigate_system:sep(0)>>>")
        print(json.dumps(_error_payload(e, "/monitor/system/status")))
    
    # Ottieni informazioni firmware
    try:
        response = requests.get(
            f"{base_url}/monitor/system/firmware",
            headers=headers,
            verify=False,
            timeout=args.timeout,
        )
        response.raise_for_status()
        firmware_data = _normalize_firmware_payload(response.json())
        # Inject monitoring configuration flag into payload for the check plugin
        try:
            if isinstance(firmware_data, dict):
                cfg = firmware_data.get("config", {}) if isinstance(firmware_data.get("config"), dict) else {}
                cfg.update({"critical_on_branch_change": bool(args.branch_change_critical)})
                firmware_data["config"] = cfg
        except Exception:
            pass

        print("<<<fortigate_firmware:sep(0)>>>")
        print(json.dumps(firmware_data))

    except Exception as e:
        print("<<<fortigate_firmware:sep(0)>>>")
        print(json.dumps(_error_payload(e, "/monitor/system/firmware")))

    # ==============================================
    # OpenCVE product CVEs
    # ==============================================
    def _print_opencve_error(exc: Exception, detail_msg: str = "", url: Optional[str] = None):
        print("<<<fortigate_cves:sep(0)>>>")
        payload = _error_payload(exc, "/api/vendors/<vendor>/products/<product>/cve")
        if detail_msg:
            payload["detail"] = f"{payload.get('detail', '')} | {detail_msg}".strip()
        if url:
            payload["url"] = url
        print(json.dumps(payload))

    if args.opencve_enabled and args.opencve_vendor and args.opencve_product:
        try:
            # Normalize API base: accept base URLs with or without trailing '/api'
            ocve_base_raw = (args.opencve_base_url or "").strip()
            ocve_base = ocve_base_raw.rstrip("/")
            api_base = ocve_base if ocve_base.endswith("/api") else f"{ocve_base}/api"
            ocve_url = f"{api_base}/vendors/{args.opencve_vendor}/products/{args.opencve_product}/cve"
            # Password must come from ruleset via --opencve-pass
            ocve_user = args.opencve_user or None
            ocve_pass = args.opencve_pass

            # Basic sanity for required auth parameters
            if not ocve_user or (ocve_pass is None):
                raise ValueError(
                    "Missing OpenCVE username or password. Ensure the ruleset provides --opencve-user and --opencve-pass."
                )

            # Build headers, include explicit Basic Authorization like curl
            headers = {
                "Accept": "application/json",
                "User-Agent": "checkmk-fortios-fw/1.0 (+OpenCVE integration)",
            }
            if ocve_user is not None:
                cred = f"{ocve_user}:{ocve_pass or ''}".encode("utf-8")
                b64 = base64.b64encode(cred).decode("ascii")
                headers["Authorization"] = f"Basic {b64}"

            # Optional quick test to distinguish auth vs permission (prints to stderr)
            if args.opencve_debug:
                try:
                    test_url = f"{api_base}/cve"
                    tr = requests.get(
                        test_url,
                        headers=headers,
                        timeout=args.opencve_conn_timeout,
                        verify=not bool(args.opencve_no_verify),
                    )
                    sys.stderr.write(
                        f"OpenCVE DEBUG test {test_url} -> {tr.status_code} {tr.reason}\n{(tr.text or '')[:200]}\n"
                    )
                except Exception as _:
                    pass

            # One request is enough to get the total count; also collect first page CVE IDs
            resp = requests.get(
                ocve_url,
                headers=headers,
                timeout=args.opencve_conn_timeout,
                verify=not bool(args.opencve_no_verify),
            )
            resp.raise_for_status()
            data = resp.json()

            count = int(data.get("count", 0)) if isinstance(data, dict) else 0
            results = data.get("results", []) if isinstance(data, dict) else []
            list_limit = max(0, int(args.opencve_list_limit or 0))
            sample_ids = [
                (item.get("cve_id") or item.get("id") or "")
                for item in results
            ]
            sample_ids = [c for c in sample_ids if c][:list_limit]

            out = {
                "status": "success",
                "vendor": args.opencve_vendor,
                "product": args.opencve_product,
                "url": ocve_url,
                "count": count,
                "sample_ids": sample_ids,
                "config": {
                    "warn_threshold": int(args.opencve_warn_threshold),
                    "crit_threshold": int(args.opencve_crit_threshold),
                },
            }

            print("<<<fortigate_cves:sep(0)>>>")
            print(json.dumps(out))

        except Exception as e:
            _print_opencve_error(e, url=locals().get("ocve_url"))

if __name__ == "__main__":
    main()
