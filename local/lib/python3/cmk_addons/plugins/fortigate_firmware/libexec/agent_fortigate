#!/usr/bin/env python3

import sys
import json
import requests
import argparse
from urllib3.exceptions import InsecureRequestWarning
from typing import Dict, Any, Optional
from requests import exceptions as req_exc

# Disabilita avvisi SSL
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def main():
    parser = argparse.ArgumentParser(description="CheckMK Special Agent for FortiGate")
    parser.add_argument("--hostname", required=True, help="FortiGate hostname or IP")
    parser.add_argument("--api-key", required=True, help="FortiGate API key")
    parser.add_argument("--port", type=int, default=443, help="HTTPS port (default: 443)")
    parser.add_argument("--timeout", type=int, default=30, help="Timeout in seconds")
    parser.add_argument(
        "--branch-change-critical",
        dest="branch_change_critical",
        action="store_true",
        default=True,
        help="Consider branch change critical (default)",
    )
    parser.add_argument(
        "--no-branch-change-critical",
        dest="branch_change_critical",
        action="store_false",
        help="Do not consider branch change critical",
    )

    # OpenCVE integration options
    parser.add_argument("--opencve-enabled", dest="opencve_enabled", action="store_true", default=False,
                        help="Enable OpenCVE lookup for product CVEs")
    parser.add_argument("--opencve-base-url", dest="opencve_base_url", default="https://app.opencve.io",
                        help="OpenCVE base URL (self-hostable)")
    parser.add_argument("--opencve-user", dest="opencve_user", default=None, help="OpenCVE username")
    parser.add_argument("--opencve-pass", dest="opencve_pass", default=None, help="OpenCVE password")
    parser.add_argument("--opencve-vendor", dest="opencve_vendor", default=None, help="Product vendor name")
    parser.add_argument("--opencve-product", dest="opencve_product", default=None, help="Product name")
    parser.add_argument("--opencve-conn-timeout", dest="opencve_conn_timeout", type=int, default=20,
                        help="Timeout in seconds for OpenCVE requests")
    parser.add_argument("--opencve-list-limit", dest="opencve_list_limit", type=int, default=10,
                        help="Max number of CVE IDs to include from first page")
    parser.add_argument("--opencve-warn-threshold", dest="opencve_warn_threshold", type=int, default=1,
                        help=" WARN when total CVEs >= this value")
    parser.add_argument("--opencve-crit-threshold", dest="opencve_crit_threshold", type=int, default=5,
                        help=" CRIT when total CVEs >= this value")
    
    args = parser.parse_args()
    
    base_url = f"https://{args.hostname}:{args.port}/api/v2"
    headers = {
        "Authorization": f"Bearer {args.api_key}",
        "Content-Type": "application/json"
    }
    
    # Helper to classify exceptions into structured, short messages
    def _error_payload(exc: Exception, endpoint: str) -> Dict[str, Any]:
        msg = str(exc)
        text = msg.lower()
        error_type = "request"
        # Classify common connection issues
        if isinstance(exc, (req_exc.ConnectTimeout, req_exc.ReadTimeout, req_exc.Timeout)) or "timed out" in text:
            error_type = "timeout"
            short = "Connection timed out"
        elif isinstance(exc, req_exc.SSLError) or "ssl" in text:
            error_type = "ssl"
            short = "SSL error"
        elif isinstance(exc, req_exc.ConnectionError) or any(s in text for s in [
            "failed to establish a new connection",
            "no route to host",
            "name or service not known",
            "temporary failure in name resolution",
            "connection refused",
        ]):
            error_type = "connection"
            # Try to produce a concise, friendly message
            if "no route to host" in text:
                short = "No route to host"
            elif "name or service not known" in text or "name resolution" in text:
                short = "DNS resolution failed"
            elif "connection refused" in text:
                short = "Connection refused"
            else:
                short = "Failed to connect"
        elif isinstance(exc, req_exc.HTTPError):
            error_type = "http"
            status = getattr(exc.response, 'status_code', 'unknown')
            short = f"HTTP error: {status}"
        else:
            short = "Request failed"

        payload: Dict[str, Any] = {
            "status": "error",
            "error": error_type,
            "message": short,
            "endpoint": endpoint,
            "detail": msg,
        }
        # Attach HTTP response details if available
        try:
            if isinstance(exc, req_exc.HTTPError) and exc.response is not None:
                payload["http_status"] = getattr(exc.response, 'status_code', None)
                payload["reason"] = getattr(exc.response, 'reason', None)
                body = exc.response.text or ""
                if body:
                    payload["response_snippet"] = body[:400]
        except Exception:
            pass
        return payload

    # Ottieni informazioni sistema
    try:
        response = requests.get(
            f"{base_url}/monitor/system/status",
            headers=headers,
            verify=False,
            timeout=args.timeout,
        )
        response.raise_for_status()
        system_data = response.json()

        print("<<<fortigate_system:sep(0)>>>")
        print(json.dumps(system_data))

    except Exception as e:
        print("<<<fortigate_system:sep(0)>>>")
        print(json.dumps(_error_payload(e, "/monitor/system/status")))
    
    # Ottieni informazioni firmware
    try:
        response = requests.get(
            f"{base_url}/monitor/system/firmware",
            headers=headers,
            verify=False,
            timeout=args.timeout,
        )
        response.raise_for_status()
        firmware_data = response.json()
        # Inject monitoring configuration flag into payload for the check plugin
        try:
            if isinstance(firmware_data, dict):
                cfg = firmware_data.get("config", {}) if isinstance(firmware_data.get("config"), dict) else {}
                cfg.update({"critical_on_branch_change": bool(args.branch_change_critical)})
                firmware_data["config"] = cfg
        except Exception:
            pass

        print("<<<fortigate_firmware:sep(0)>>>")
        print(json.dumps(firmware_data))

    except Exception as e:
        print("<<<fortigate_firmware:sep(0)>>>")
        print(json.dumps(_error_payload(e, "/monitor/system/firmware")))

    # ==============================================
    # OpenCVE product CVEs
    # ==============================================
    def _print_opencve_error(exc: Exception, detail_msg: str = ""):
        print("<<<fortigate_cves:sep(0)>>>")
        payload = _error_payload(exc, "/api/vendors/<vendor>/products/<product>/cve")
        if detail_msg:
            payload["detail"] = f"{payload.get('detail', '')} | {detail_msg}".strip()
        print(json.dumps(payload))

    if args.opencve_enabled and args.opencve_vendor and args.opencve_product:
        try:
            ocve_base = args.opencve_base_url.rstrip("/")
            ocve_url = f"{ocve_base}/api/vendors/{args.opencve_vendor}/products/{args.opencve_product}/cve"

            auth: Optional[tuple[str, str]] = None
            if args.opencve_user:
                auth = (args.opencve_user, args.opencve_pass or "")

            # One request is enough to get the total count; also collect first page CVE IDs
            resp = requests.get(
                ocve_url,
                auth=auth,
                headers={
                    "Accept": "application/json",
                    "User-Agent": "checkmk-fortios-fw/1.0 (+OpenCVE integration)",
                },
                timeout=args.opencve_conn_timeout,
                verify=False,
            )
            resp.raise_for_status()
            data = resp.json()

            count = int(data.get("count", 0)) if isinstance(data, dict) else 0
            results = data.get("results", []) if isinstance(data, dict) else []
            list_limit = max(0, int(args.opencve_list_limit or 0))
            sample_ids = [
                (item.get("cve_id") or item.get("id") or "")
                for item in results
            ]
            sample_ids = [c for c in sample_ids if c][:list_limit]

            out = {
                "status": "success",
                "vendor": args.opencve_vendor,
                "product": args.opencve_product,
                "url": ocve_url,
                "count": count,
                "sample_ids": sample_ids,
                "config": {
                    "warn_threshold": int(args.opencve_warn_threshold),
                    "crit_threshold": int(args.opencve_crit_threshold),
                },
            }

            print("<<<fortigate_cves:sep(0)>>>")
            print(json.dumps(out))

        except Exception as e:
            _print_opencve_error(e)

if __name__ == "__main__":
    main()
